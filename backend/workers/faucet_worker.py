"""FaucetHunter worker.

This worker claims rewards from a list of crypto faucets and records
those outcomes into Supabase.  It listens for directives targeted at
``FaucetHunter`` and responds to commands such as ``CLAIM_FAUCETS``.  In
the absence of directives the worker quietly cycles through its list of
faucets, ensuring the swarm continues earning tokens.

### Faucet list configuration

The faucet list can be customised in several ways:

1. **Environment variable** – If ``FAUCETS_FILE_PATH`` is set, the
   worker will attempt to load a JSON or YAML file at that path.  The
   file should contain a list of objects with at least ``name`` and
   ``url`` keys (and optionally other metadata).  This allows you to
   supply your own curated list or convert the provided
   ``TOP_200_CRYPTO_FAUCETS_DATABASE.ts`` into JSON.

2. **Hard‑coded entries** – If no file is provided, the worker falls
   back to the ``DEFAULT_FAUCETS`` constant defined below.  Update
   ``DEFAULT_FAUCETS`` to include your preferred faucets during
   development.

3. **Directives** – Future enhancements could allow the list to be
   modified via Supabase directives (e.g. ``ADD_FAUCET``, ``REMOVE_FAUCET``).

This flexible configuration means the FaucetHunter can adapt to new
opportunities without requiring code changes.
"""

import os
import time
import json
from pathlib import Path
from typing import Dict, Any, List

from ..supabase_utils import fetch_pending_directives, insert_log, mark_directive_complete
from ..wallet.manager import load_wallets
from .wallet_rotator import assign_wallet_to_agent  # unused but imported for docs clarity
from .api_key_rotator import get_next_api_key
from .headless_browser_agent import HeadlessBrowserAgent

try:
    import yaml  # type: ignore
except Exception:
    yaml = None  # type: ignore

AGENT_NAME = "FaucetHunter"

# Default faucet definitions.  You can modify this list during
# development, but for production deployments it is recommended to
# provide a JSON/YAML file via FAUCETS_FILE_PATH.
DEFAULT_FAUCETS = [
    {"name": "solfaucet.com", "url": "https://solfaucet.com"},
    {"name": "ethdrop.io", "url": "https://ethdrop.io"},
    {"name": "matic-rewards", "url": "https://maticrewards.com"},
]


def load_faucets() -> list[dict]:
    """Load the faucet list from a file or return defaults.

    If the environment variable ``FAUCETS_FILE_PATH`` is defined and
    points to a valid JSON or YAML file, the contents of that file will
    be parsed and returned.  Otherwise the ``DEFAULT_FAUCETS`` list is
    returned.  Errors encountered during parsing are logged and result
    in the default list being used.
    """
    path = os.getenv("FAUCETS_FILE_PATH")
    if not path:
        return DEFAULT_FAUCETS
    try:
        with open(path, "r", encoding="utf-8") as f:
            if path.lower().endswith(".yaml") or path.lower().endswith(".yml"):
                if yaml:
                    data = yaml.safe_load(f)  # type: ignore
                else:
                    raise RuntimeError("yaml module not available")
            else:
                import json

                data = json.load(f)
            if isinstance(data, list):
                # Basic validation: ensure each entry has a name and URL
                valid_entries = [entry for entry in data if entry.get("name") and entry.get("url")]
                return valid_entries or DEFAULT_FAUCETS
    except Exception as e:
        insert_log(
            "agent_logs",
            {
                "agent": AGENT_NAME,
                "event": "faucet_file_error",
                "details": str(e),
            },
        )
    return DEFAULT_FAUCETS


# At module import time, load the faucets list.  This allows the worker to
# dynamically pick up changes if the environment variable is modified
# before the process starts.  For runtime hot‑reloading, consider
# reloading this list in the worker loop.
FAUCETS: list[dict] = load_faucets()

# -----------------------------------------------------------------------------
# Wallet rotation helpers
#
# To avoid reusing the same wallet address for multiple claims, the faucet
# worker rotates through a pool of addresses.  Addresses can be provided via
# the ``WALLET_ADDRESSES`` environment variable (comma separated).  If not
# provided, the worker falls back to any wallets stored in the local
# ``wallet_ledger.json`` generated by the wallet manager.  Rotation state is
# persisted to a JSON file relative to this package.  Adjust the
# ``WALLET_ROTATION_STATE_FILE`` environment variable to customise the path.
# -----------------------------------------------------------------------------

def _get_wallet_list() -> List[str]:
    """Return a list of wallet addresses available for faucet claims.

    Priority is given to the ``WALLET_ADDRESSES`` environment variable.  If
    missing, the ledger from ``wallet.manager`` is used.  If still empty,
    returns a single placeholder address.
    """
    env_list = os.getenv("WALLET_ADDRESSES")
    if env_list:
        wallets = [addr.strip() for addr in env_list.split(",") if addr.strip()]
        if wallets:
            return wallets
    # Fallback to loaded wallets from the ledger file
    try:
        ledger = load_wallets()
        addresses = [entry.get("address") for entry in ledger if entry.get("address")]
        if addresses:
            return addresses
    except Exception:
        pass
    # Final fallback: placeholder address to avoid crashes
    return ["0x0000"]


def _rotation_state_path() -> Path:
    """Return the path to the wallet rotation state file."""
    custom = os.getenv("WALLET_ROTATION_STATE_FILE")
    if custom:
        return Path(custom)
    # Default: locate state file in the backend package directory
    return Path(__file__).resolve().parent / "wallet_rotation_state.json"


def _load_rotation_state() -> dict:
    """Load the wallet rotation state from disk.

    Returns a dictionary with at least the key ``index``.
    """
    state_file = _rotation_state_path()
    if state_file.exists():
        try:
            with state_file.open("r") as f:
                data = json.load(f)
                if isinstance(data, dict) and "index" in data:
                    return data
        except Exception:
            pass
    return {"index": 0}


def _save_rotation_state(state: dict) -> None:
    """Persist the wallet rotation state to disk."""
    state_file = _rotation_state_path()
    try:
        with state_file.open("w") as f:
            json.dump(state, f)
    except Exception as e:
        # Log to Supabase if saving fails
        insert_log(
            "agent_logs",
            {
                "agent": AGENT_NAME,
                "event": "wallet_rotation_save_error",
                "details": str(e),
            },
        )


def get_next_wallet() -> str:
    """Return the next wallet address in the rotation.

    The list of available wallets is determined by ``_get_wallet_list``.
    Rotation state is stored in a JSON file.  On each call the state
    advances to the next index and is persisted.  If the list has only one
    entry, the same address will be returned every time.
    """
    wallets = _get_wallet_list()
    state = _load_rotation_state()
    index = state.get("index", 0)
    if not wallets:
        return "0x0000"
    # Ensure index is within bounds
    index = index % len(wallets)
    wallet = wallets[index]
    # Advance index for next call
    state["index"] = (index + 1) % len(wallets)
    _save_rotation_state(state)
    return wallet


def claim_faucet(faucet: Dict[str, Any]) -> Dict[str, Any]:
    """Claim from the given faucet using wallet and API key rotation.

    This function orchestrates the process of claiming a reward from a
    faucet.  It obtains the next wallet address via ``get_next_wallet``
    (defined above) and the next API key via ``get_next_api_key``.  It
    then decides whether to use a headless browser or a simple HTTP
    request based on the ``USE_HEADLESS`` environment variable.  If
    headless mode is enabled and Playwright is installed, the claim is
    attempted via ``HeadlessBrowserAgent``; otherwise a simple HTTP
    GET request is made to the faucet URL.  The result is returned as
    a dictionary with at least ``faucet``, ``claimed``, ``amount`` and
    ``token`` keys.

    If errors occur during the claim process they are logged to
    Supabase via ``insert_log`` and a failed result is returned.
    """
    # Use the locally defined get_next_wallet() for wallet rotation
    wallet_addr = get_next_wallet()
    api_key = get_next_api_key()
    use_headless = os.getenv("USE_HEADLESS", "false").lower() in ("1", "true", "yes")
    faucet_name = faucet.get("name", faucet.get("url", "unknown"))
    url = faucet.get("url")
    result: Dict[str, Any] = {
        "faucet": faucet_name,
        "claimed": False,
        "amount": 0.0,
        "token": "",
    }
    try:
        if use_headless:
            # Use the headless browser agent if available
            agent = HeadlessBrowserAgent()  # may raise ImportError if playwright missing
            try:
                claim_res = agent.claim(url, wallet=wallet_addr, api_key=api_key)
                result.update(claim_res)
            finally:
                agent.close()
        else:
            # Fallback to simple HTTP request.  Append wallet and API key as query params
            import requests  # type: ignore
            params = {"wallet": wallet_addr}
            if api_key:
                params["api_key"] = api_key
            resp = requests.get(url, params=params, timeout=10)
            if resp.ok:
                # Attempt to parse JSON response
                try:
                    data = resp.json()
                    result.update({
                        "faucet": faucet_name,
                        "claimed": bool(data.get("claimed", True)),
                        "amount": float(data.get("amount", 0.0)),
                        "token": str(data.get("token", "")),
                    })
                except Exception:
                    # Fallback: treat as success if status code 200
                    result.update({"claimed": True, "amount": 0.001, "token": ""})
            else:
                result.update({"claimed": False})
    except Exception as e:
        # Log the error and return a failure result
        insert_log(
            "agent_logs",
            {
                "agent": AGENT_NAME,
                "event": "claim_error",
                "details": {"faucet": faucet_name, "error": str(e)},
            },
        )
        result.update({"claimed": False})
    return result


def process_directive(directive: Dict[str, Any]) -> None:
    """Execute a directive received from Supabase."""
    directive_id = directive["id"]
    command = directive["command"]
    payload = directive.get("payload", {})

    if command == "CLAIM_FAUCETS":
        results = []
        for faucet in FAUCETS:
            res = claim_faucet(faucet)
            results.append(res)
            insert_log("faucet_logs", {"agent": AGENT_NAME, **res})
        insert_log("agent_logs", {"agent": AGENT_NAME, "event": "claimed faucets", "details": results})

    elif command == "PING":
        # Simple heartbeat command
        insert_log("agent_logs", {"agent": AGENT_NAME, "event": "ping", "details": payload})

    else:
        insert_log("agent_logs", {"agent": AGENT_NAME, "event": "unknown_directive", "details": command})

    # Mark directive as complete
    mark_directive_complete(directive_id)


def default_behaviour() -> None:
    """Run when no directives are pending.

    The default behaviour is to cycle through the faucet list and claim
    rewards quietly.  This ensures that the worker still earns crypto
    when it is not processing explicit commands.
    """
    for faucet in FAUCETS:
        res = claim_faucet(faucet)
        insert_log("faucet_logs", {"agent": AGENT_NAME, **res})
    insert_log("agent_logs", {"agent": AGENT_NAME, "event": "heartbeat", "details": "claimed default faucets"})


def run_worker() -> None:
    """Main polling loop for the FaucetHunter worker."""
    while True:
        directives = fetch_pending_directives(AGENT_NAME)
        if directives:
            # Process the first pending directive
            process_directive(directives[0])
        else:
            # Perform default behaviour
            default_behaviour()
        # Sleep briefly before polling again
        time.sleep(60)


if __name__ == "__main__":
    run_worker()
